#!/usr/bin/env bash
# shellcheck -x
#
# Summary: Run the BATS test files
#
# Useage:  test/run
#
# 
set -o errexit          # Exit on most errors (see the manual)
set -o errtrace         # Make sure any error trap is inherited
# set -o nounset          # Disallow expansion of unset variables
set -o pipefail         # Use last non-zero exit code in a pipeline
set -o xtrace          # Trace the execution of the script (debug)

# DESC: Generic script initialisation (useful paths)
# ARGS: $@ (optional): Arguments provided to the script
# OUTS: $orig_cwd: The current working directory when the script was run
#       $script_path: The full path to the script
#       $script_dir: The directory path of the script
#       $script_name: The file name of the script
#       $script_params: The original parameters provided to the script
#       $ta_none: The ANSI control code to reset all text attributes
# NOTE: $script_path only contains the path that was used to call the script
#       and will not resolve any symlinks which may be present in the path.
#       You can use a tool like GNU CoreUtils readlink or realpath to obtain
#       the "true" path. 
#       The same caveat applies to the $script_dir and $script_name variables.
function script_init() {

    readonly orig_cwd="$PWD"
    readonly script_path="${BASH_SOURCE[0]}"
    readonly script_dir="$( cd "$( dirname "${script_path}" )" >/dev/null 2>&1 && pwd )"
    readonly script_name="$(basename "$script_path")"
    readonly script_params="$*"

    # Important to always set as we use it in the exit handler
    readonly ta_none="$(tput sgr0 2> /dev/null || true)"
}

script_init

# Build the bash extension
if [ "${JLENV_NATIVE_EXT:-false}" = "true" ]; then
  src/configure
  make -C src
fi

# Setup the bats environment for testing.
if [ -d libs/bats ] && [ -d libs/bats-assert ] && [ -d libs/bats-file ] && [ -d libs/bats-mock ] && [ -d libs/bats-support ]
then
  # shellcheck source=/refresh_submodules.bash
  source "${script_dir}/refresh_submodules.bash"
else
  # shellcheck source=/setup_bats.bash
  source "${script_dir}/setup_bats.bash"
fi

# We should now be at the plugin root folder.  
# exec "${script_dir}/libs/bats/bin/bats" ${CI:+--tap} test

exec ${script_dir}/libs/bats/bin/bats --tap test |tee bats.log

bats_table()
{
  echo 'Bats test failed count:'
  cat bats.log |
    sed -e '/^not ok\|\.bats/!d' |
    tr '[:space:]' '[\n*]' |
    sort |
    uniq -c |
    sort -nr |
    grep bats | tee bats.tbl
}

bats_not_descriptions() 
{
  cat bats.log|
    sed -e '/^not ok/!d'|
    cut -f4- -d ' ' >bats.not
}

bats_not_cmds() 
{
  echo 'export JLENV_DEBUG=1' >bats_not.cmds
  cat bats.not | while read -r line; do echo "${script_dir}/libs/bats/bin/bats -f '${line}' test" >>bats_not.cmds; done
}

bats_table
bats_not_descriptions
bats_not_cmds

cat bats.tbl
cat bats_not.cmds

bash bats_not.cmds
